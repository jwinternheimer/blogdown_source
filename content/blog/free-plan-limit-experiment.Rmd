---
title: "Free Plan Limits Experiment"
output: github_document
---

The new free plan limits will be rolled out fairly soon. With that, it would be awesome to design an experiment that would allow us to test the assumptions we have about these limits and measure the impact that these changes have on users.

From my perspective, the main assumption we want to test is that adding more limits to the free plan will increase the proportion of new users that pay for a subscription and thus increase average revenue per user. 

There will also be an effect on the number of daily active users that Buffer has, but I suspect that is of less concern.

Things to take into account:

- Number of daily signups
- Amount of time it takes to upgrade
- Trial length
- Effect size

### Daily signups
We can use a simple SQL query to get the number of daily and weekly signups.

```{r include = FALSE, warning = FALSE, message = FALSE}
library(buffer); library(dplyr); library(ggplot2); library(lubridate); library(ggridges)

# connect to redshift
con <- redshift_connect()
```

```{sql connection = con, output.var = signups}
select
  date(created_at) as date
  , count(*) as users
from users
where created_at >= '2017-01-01'
group by 1
```

Let's look at the signup numbers from the past 270 days.

```{r echo = FALSE}
ggplot(signups, aes(x = date, y = users)) +
  geom_line() +
  theme_minimal() +
  labs(x = NULL, y = NULL, title = "Daily Signups")
```

Well, there are a couple of clear outliers here. Let's remove these days and replace them with the mean number for that day of the week.

```{r warning = FALSE, message = FALSE}
# set outliers values to NA
signups[signups$users > 6000,]$users <- NA

# replace NAs with the mean for the day of week
signups <- signups %>%
  group_by(day_of_week) %>%
  mutate_each(funs(replace(., which(is.na(.)), mean(., na.rm = TRUE))))

# plot signups
ggplot(signups, aes(x = date, y = users)) +
  geom_line() +
  theme_minimal() +
  labs(x = NULL, y = NULL, title = "Daily Signups")
```

It looks like we get between 3000 and 5000 signups per day, depending on the day of week. Let's look at the distributions just for fun. 

```{r echo = FALSE, warning = FALSE, message = FALSE}
# get weekday number
signups <- signups %>%
  mutate(wday <- wday(date)) %>%
  mutate(wday = ifelse(day_of_week == "Sunday", 7, wday - 1))

# order the data
signups <- group_by(signups, day_of_week) %>%
       mutate(m = mean(users)) %>%
       arrange(desc(wday)) %>%
       ungroup() %>%
       mutate(day_of_week = factor(day_of_week, unique(day_of_week)))

# plot team members and updates
ggplot(signups, aes(x = users, y = day_of_week, fill = day_of_week)) +
  geom_density_ridges(rel_min_height = 0.01, scale = 2, color = 'white') +
  theme_ridges() +
  scale_fill_cyclical(values = c("#2A7FFF", "#5599FF")) +
  labs(x = "Signups", y = NULL)
```

Now let's look at the number of weekly singups.

```{r}
# get week
signups <- signups %>%
  mutate(week = floor_date(date, unit = 'week'))

# plot weekly signups
signups %>% 
  filter(week != max(week)) %>%
  group_by(week) %>%
  summarise(users = sum(users)) %>%
  ggplot(aes(x = users)) +
  geom_density(color = 'white', fill = '#5599FF') +
  theme_minimal() +
  labs(x = NULL, y = NULL, title = "Weekly Signups")
```

Now let's try to get a sense of the amount of time it takes users to subscribe to a paid plan. We'll gather all users that have subscribed to a paid plan this year, and look at the amount of time it took them to upgrade.

```{sql connection = con, output.var = customers}
with charge_dates as(
  select 
    customer
    , date(min(created)) as first_charge_date
    , date(max(created)) as last_charge_date
  from stripe._charges
  where captured and paid
  group by customer
)

select
  user_id
  , billing_stripe_id as customer_id
  , date(created_at) as created_at
  , first_charge_date
  , last_charge_date
from users
join charge_dates
  on users.billing_stripe_id = charge_dates.customer
where date(users.created_at) >= '2017-01-01'
```

Now we can calculate the number of days it took users to upgrade.

```{r}
# get created week and month
customers <- customers %>%
  mutate(created_week = floor_date(created_at, 'week'), 
         created_month = floor_date(created_at, 'month'),
         days_to_upgrade = as.numeric(first_charge_date - created_at)) %>%
  mutate(month_label = month(created_month, label = TRUE))
```

Let's begin by looking at users that joined in the month of January and upgraded. What does the distribution of `days_to_upgrade` look like for them?

```{r echo = FALSE, warning = FALSE, message = FALSE}
customers %>%
  filter(created_month == '2017-01-01' & days_to_upgrade >= 0) %>%
  ggplot(aes(x = days_to_upgrade)) +
  geom_density(color = 'white', fill = '#5599FF') +
  theme_minimal() +
  scale_x_continuous(limits = c(0, 180), breaks = seq(0, 180, 30)) +
  labs(x = NULL, y = NULL, title = "Number of Days to Upgrade")
```

It looks like many users that did subscribe to a paid plan did so within the first couple of weeks after signing up.

```{r echo = FALSE, warning = FALSE, message = FALSE}
customers %>%
  filter(days_to_upgrade >= 0) %>%
  ggplot(aes(x = days_to_upgrade, color = month_label)) +
  stat_ecdf() +
  theme_minimal() +
  coord_cartesian(xlim = c(0, 180)) +
  scale_x_continuous(limits = c(0, 180), breaks = seq(0, 180, 30)) +
  labs(x = NULL, y = NULL, title = "Number of Days to Upgrade", color = "Month")
```

```{r}
# unload lubridate package
detach("package:lubridate", unload = TRUE)
```